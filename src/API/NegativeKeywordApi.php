<?php
/**
 * NegativeKeywordApi
 * PHP version 7.4
 *
 * @category Class
 * @package  macropage\SDKs\ebay\rest\marketing
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Marketing API
 *
 * <p>The <i>Marketing API </i> offers two platforms that sellers can use to promote and advertise their products:</p> <ul><li><b>Promoted Listings</b> is an eBay ad service that lets sellers set up <i>ad campaigns </i> for the products they want to promote. eBay displays the ads in search results and in other marketing modules as <b>SPONSORED</b> listings. If an item in a Promoted Listings campaign sells, the seller is assessed a Promoted Listings fee, which is a seller-specified percentage applied to the sales price. For complete details, refer to the <a href=\"/api-docs/sell/static/marketing/pl-landing.html\">Promoted Listings playbook</a>.</li><li><b>Promotions Manager</b> gives sellers a way to offer discounts on specific items as a way to attract buyers to their inventory. Sellers can set up discounts (such as \"20% off\" and other types of offers) on specific items or on an entire customer order. To further attract buyers, eBay prominently displays promotion <i>teasers</i> throughout buyer flows. For complete details, see <a href=\"/api-docs/sell/static/marketing/promotions-manager.html\">Promotions Manager</a>.</li></ul>  <p><b>Marketing reports</b>, on both the Promoted Listings and Promotions Manager platforms, give sellers information that shows the effectiveness of their marketing strategies. The data gives sellers the ability to review and fine tune their marketing efforts.</p><p><b>Store Email Campaign</b> allows sellers to create and send email campaigns to customers who have signed up to receive their newsletter. For more information on email campaigns, see <a href=\"/api-docs/sell/static/marketing/store-email-campaigns.html#email-campain-types\" target=\"_blank\">Store Email Campaigns</a>.<p class=\"tablenote\"><b>Important!</b> Sellers must have an active eBay Store subscription, and they must accept the <b>Terms and Conditions</b> before they can make requests to these APIs in the Production environment. There are also site-specific listings requirements and restrictions associated with these marketing tools, as listed in the \"requirements and restrictions\" sections for <a href=\"/api-docs/sell/marketing/static/overview.html#PL-requirements\">Promoted Listings</a> and <a href=\"/api-docs/sell/marketing/static/overview.html#PM-requirements\">Promotions Manager</a>.</p> <p>The table below lists all the Marketing API calls grouped by resource.</p>
 *
 * The version of the OpenAPI document: v1.22.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace macropage\SDKs\ebay\rest\marketing\API;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use macropage\SDKs\ebay\rest\marketing\ApiException;
use macropage\SDKs\ebay\rest\marketing\Configuration;
use macropage\SDKs\ebay\rest\marketing\HeaderSelector;
use macropage\SDKs\ebay\rest\marketing\ObjectSerializer;

/**
 * NegativeKeywordApi Class Doc Comment
 *
 * @category Class
 * @package  macropage\SDKs\ebay\rest\marketing
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class NegativeKeywordApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'bulkCreateNegativeKeyword' => [
            'application/json',
        ],
        'bulkUpdateNegativeKeyword' => [
            'application/json',
        ],
        'createNegativeKeyword' => [
            'application/json',
        ],
        'getNegativeKeyword' => [
            'application/json',
        ],
        'getNegativeKeywords' => [
            'application/json',
        ],
        'updateNegativeKeyword' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation bulkCreateNegativeKeyword
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordRequest $bulkCreateNegativeKeywordRequest A type that defines the fields for the bulk request to create negative keywords. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse
     */
    public function bulkCreateNegativeKeyword($bulkCreateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkCreateNegativeKeyword'][0])
    {
        list($response) = $this->bulkCreateNegativeKeywordWithHttpInfo($bulkCreateNegativeKeywordRequest, $contentType);
        return $response;
    }

    /**
     * Operation bulkCreateNegativeKeywordWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordRequest $bulkCreateNegativeKeywordRequest A type that defines the fields for the bulk request to create negative keywords. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkCreateNegativeKeywordWithHttpInfo($bulkCreateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkCreateNegativeKeyword'][0])
    {
        $request = $this->bulkCreateNegativeKeywordRequest($bulkCreateNegativeKeywordRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkCreateNegativeKeywordAsync
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordRequest $bulkCreateNegativeKeywordRequest A type that defines the fields for the bulk request to create negative keywords. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkCreateNegativeKeywordAsync($bulkCreateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkCreateNegativeKeyword'][0])
    {
        return $this->bulkCreateNegativeKeywordAsyncWithHttpInfo($bulkCreateNegativeKeywordRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkCreateNegativeKeywordAsyncWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordRequest $bulkCreateNegativeKeywordRequest A type that defines the fields for the bulk request to create negative keywords. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkCreateNegativeKeywordAsyncWithHttpInfo($bulkCreateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkCreateNegativeKeyword'][0])
    {
        $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordResponse';
        $request = $this->bulkCreateNegativeKeywordRequest($bulkCreateNegativeKeywordRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkCreateNegativeKeyword'
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkCreateNegativeKeywordRequest $bulkCreateNegativeKeywordRequest A type that defines the fields for the bulk request to create negative keywords. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkCreateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkCreateNegativeKeywordRequest($bulkCreateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkCreateNegativeKeyword'][0])
    {

        // verify the required parameter 'bulkCreateNegativeKeywordRequest' is set
        if ($bulkCreateNegativeKeywordRequest === null || (is_array($bulkCreateNegativeKeywordRequest) && count($bulkCreateNegativeKeywordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulkCreateNegativeKeywordRequest when calling bulkCreateNegativeKeyword'
            );
        }


        $resourcePath = '/bulk_create_negative_keyword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulkCreateNegativeKeywordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulkCreateNegativeKeywordRequest));
            } else {
                $httpBody = $bulkCreateNegativeKeywordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation bulkUpdateNegativeKeyword
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordRequest $bulkUpdateNegativeKeywordRequest A type that defines the fields for the bulk request to update negative keyword statuses. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse
     */
    public function bulkUpdateNegativeKeyword($bulkUpdateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkUpdateNegativeKeyword'][0])
    {
        list($response) = $this->bulkUpdateNegativeKeywordWithHttpInfo($bulkUpdateNegativeKeywordRequest, $contentType);
        return $response;
    }

    /**
     * Operation bulkUpdateNegativeKeywordWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordRequest $bulkUpdateNegativeKeywordRequest A type that defines the fields for the bulk request to update negative keyword statuses. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function bulkUpdateNegativeKeywordWithHttpInfo($bulkUpdateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkUpdateNegativeKeyword'][0])
    {
        $request = $this->bulkUpdateNegativeKeywordRequest($bulkUpdateNegativeKeywordRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation bulkUpdateNegativeKeywordAsync
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordRequest $bulkUpdateNegativeKeywordRequest A type that defines the fields for the bulk request to update negative keyword statuses. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateNegativeKeywordAsync($bulkUpdateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkUpdateNegativeKeyword'][0])
    {
        return $this->bulkUpdateNegativeKeywordAsyncWithHttpInfo($bulkUpdateNegativeKeywordRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation bulkUpdateNegativeKeywordAsyncWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordRequest $bulkUpdateNegativeKeywordRequest A type that defines the fields for the bulk request to update negative keyword statuses. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function bulkUpdateNegativeKeywordAsyncWithHttpInfo($bulkUpdateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkUpdateNegativeKeyword'][0])
    {
        $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordResponse';
        $request = $this->bulkUpdateNegativeKeywordRequest($bulkUpdateNegativeKeywordRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'bulkUpdateNegativeKeyword'
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\BulkUpdateNegativeKeywordRequest $bulkUpdateNegativeKeywordRequest A type that defines the fields for the bulk request to update negative keyword statuses. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['bulkUpdateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function bulkUpdateNegativeKeywordRequest($bulkUpdateNegativeKeywordRequest, string $contentType = self::contentTypes['bulkUpdateNegativeKeyword'][0])
    {

        // verify the required parameter 'bulkUpdateNegativeKeywordRequest' is set
        if ($bulkUpdateNegativeKeywordRequest === null || (is_array($bulkUpdateNegativeKeywordRequest) && count($bulkUpdateNegativeKeywordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bulkUpdateNegativeKeywordRequest when calling bulkUpdateNegativeKeyword'
            );
        }


        $resourcePath = '/bulk_update_negative_keyword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($bulkUpdateNegativeKeywordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($bulkUpdateNegativeKeywordRequest));
            } else {
                $httpBody = $bulkUpdateNegativeKeywordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNegativeKeyword
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\CreateNegativeKeywordRequest $createNegativeKeywordRequest A type that defines the fields for the request to create a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createNegativeKeyword($createNegativeKeywordRequest, string $contentType = self::contentTypes['createNegativeKeyword'][0])
    {
        list($response) = $this->createNegativeKeywordWithHttpInfo($createNegativeKeywordRequest, $contentType);
        return $response;
    }

    /**
     * Operation createNegativeKeywordWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\CreateNegativeKeywordRequest $createNegativeKeywordRequest A type that defines the fields for the request to create a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNegativeKeywordWithHttpInfo($createNegativeKeywordRequest, string $contentType = self::contentTypes['createNegativeKeyword'][0])
    {
        $request = $this->createNegativeKeywordRequest($createNegativeKeywordRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('object' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('object' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'object';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNegativeKeywordAsync
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\CreateNegativeKeywordRequest $createNegativeKeywordRequest A type that defines the fields for the request to create a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNegativeKeywordAsync($createNegativeKeywordRequest, string $contentType = self::contentTypes['createNegativeKeyword'][0])
    {
        return $this->createNegativeKeywordAsyncWithHttpInfo($createNegativeKeywordRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNegativeKeywordAsyncWithHttpInfo
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\CreateNegativeKeywordRequest $createNegativeKeywordRequest A type that defines the fields for the request to create a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNegativeKeywordAsyncWithHttpInfo($createNegativeKeywordRequest, string $contentType = self::contentTypes['createNegativeKeyword'][0])
    {
        $returnType = 'object';
        $request = $this->createNegativeKeywordRequest($createNegativeKeywordRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNegativeKeyword'
     *
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\CreateNegativeKeywordRequest $createNegativeKeywordRequest A type that defines the fields for the request to create a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNegativeKeywordRequest($createNegativeKeywordRequest, string $contentType = self::contentTypes['createNegativeKeyword'][0])
    {

        // verify the required parameter 'createNegativeKeywordRequest' is set
        if ($createNegativeKeywordRequest === null || (is_array($createNegativeKeywordRequest) && count($createNegativeKeywordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $createNegativeKeywordRequest when calling createNegativeKeyword'
            );
        }


        $resourcePath = '/negative_keyword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($createNegativeKeywordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($createNegativeKeywordRequest));
            } else {
                $httpBody = $createNegativeKeywordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNegativeKeyword
     *
     * @param  string $negativeKeywordId This path parameter specifies the unique identifier for the negative keyword being retrieved.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/getNegativeKeywords\&quot; target&#x3D;\&quot;_blank \&quot;&gt; getNegativeKeywords&lt;/a&gt; method to retrieve negative keyword IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword
     */
    public function getNegativeKeyword($negativeKeywordId, string $contentType = self::contentTypes['getNegativeKeyword'][0])
    {
        list($response) = $this->getNegativeKeywordWithHttpInfo($negativeKeywordId, $contentType);
        return $response;
    }

    /**
     * Operation getNegativeKeywordWithHttpInfo
     *
     * @param  string $negativeKeywordId This path parameter specifies the unique identifier for the negative keyword being retrieved.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/getNegativeKeywords\&quot; target&#x3D;\&quot;_blank \&quot;&gt; getNegativeKeywords&lt;/a&gt; method to retrieve negative keyword IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNegativeKeywordWithHttpInfo($negativeKeywordId, string $contentType = self::contentTypes['getNegativeKeyword'][0])
    {
        $request = $this->getNegativeKeywordRequest($negativeKeywordId, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNegativeKeywordAsync
     *
     * @param  string $negativeKeywordId This path parameter specifies the unique identifier for the negative keyword being retrieved.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/getNegativeKeywords\&quot; target&#x3D;\&quot;_blank \&quot;&gt; getNegativeKeywords&lt;/a&gt; method to retrieve negative keyword IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNegativeKeywordAsync($negativeKeywordId, string $contentType = self::contentTypes['getNegativeKeyword'][0])
    {
        return $this->getNegativeKeywordAsyncWithHttpInfo($negativeKeywordId, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNegativeKeywordAsyncWithHttpInfo
     *
     * @param  string $negativeKeywordId This path parameter specifies the unique identifier for the negative keyword being retrieved.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/getNegativeKeywords\&quot; target&#x3D;\&quot;_blank \&quot;&gt; getNegativeKeywords&lt;/a&gt; method to retrieve negative keyword IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNegativeKeywordAsyncWithHttpInfo($negativeKeywordId, string $contentType = self::contentTypes['getNegativeKeyword'][0])
    {
        $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeyword';
        $request = $this->getNegativeKeywordRequest($negativeKeywordId, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNegativeKeyword'
     *
     * @param  string $negativeKeywordId This path parameter specifies the unique identifier for the negative keyword being retrieved.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/getNegativeKeywords\&quot; target&#x3D;\&quot;_blank \&quot;&gt; getNegativeKeywords&lt;/a&gt; method to retrieve negative keyword IDs. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNegativeKeywordRequest($negativeKeywordId, string $contentType = self::contentTypes['getNegativeKeyword'][0])
    {

        // verify the required parameter 'negativeKeywordId' is set
        if ($negativeKeywordId === null || (is_array($negativeKeywordId) && count($negativeKeywordId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $negativeKeywordId when calling getNegativeKeyword'
            );
        }


        $resourcePath = '/negative_keyword/{negative_keyword_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($negativeKeywordId !== null) {
            $resourcePath = str_replace(
                '{' . 'negative_keyword_id' . '}',
                ObjectSerializer::toPathValue($negativeKeywordId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNegativeKeywords
     *
     * @param  string|null $adGroupIds A comma-separated list of ad group IDs.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from one or more specific ad groups. The results might not include these ad group IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/adgroup/methods/getAdGroups\&quot;&gt;getAdGroups&lt;/a&gt; method to retrieve the ad group IDs for a seller.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Required if&lt;/i&gt; the search results must be filtered to include negative keywords created at the ad group level. (optional)
     * @param  string|null $campaignIds This path parameter specifies the unique eBay-assigned identifier of the ad campaign associated with the negative keywords being retrieved.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from a specific campaign. The results might not include these campaign IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;b&gt;Note:&lt;/b&gt; Currently, only one campaign ID value is supported for each request.&lt;/span&gt;&lt;br&gt;&lt;br&gt; Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/campaign/methods/getCampaigns\&quot; target&#x3D;\&quot;_blank\&quot;&gt;getCampaigns&lt;/a&gt; method to retrieve campaign IDs. (optional)
     * @param  string|null $limit The number of results, from the current result set, to be returned in a single page. (optional)
     * @param  string|null $negativeKeywordStatus A comma-separated list of negative keyword statuses.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to filter the search results based on one or more negative keyword statuses.&lt;br&gt;&lt;br&gt; See &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/types/pls:NegativeKeywordStatusEnum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;NegativeKeywordStatusEnum&lt;/a&gt; for supported values. (optional)
     * @param  string|null $offset The number of results that will be skipped in the result set. This is used with the &lt;b&gt;limit&lt;/b&gt; field to control the pagination of the output.&lt;br /&gt;&lt;br /&gt;For example, if the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;0&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 1 through 10 from the list of items returned. If the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 11 through 20 from the list of items returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeywords'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse
     */
    public function getNegativeKeywords($adGroupIds = null, $campaignIds = null, $limit = null, $negativeKeywordStatus = null, $offset = null, string $contentType = self::contentTypes['getNegativeKeywords'][0])
    {
        list($response) = $this->getNegativeKeywordsWithHttpInfo($adGroupIds, $campaignIds, $limit, $negativeKeywordStatus, $offset, $contentType);
        return $response;
    }

    /**
     * Operation getNegativeKeywordsWithHttpInfo
     *
     * @param  string|null $adGroupIds A comma-separated list of ad group IDs.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from one or more specific ad groups. The results might not include these ad group IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/adgroup/methods/getAdGroups\&quot;&gt;getAdGroups&lt;/a&gt; method to retrieve the ad group IDs for a seller.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Required if&lt;/i&gt; the search results must be filtered to include negative keywords created at the ad group level. (optional)
     * @param  string|null $campaignIds This path parameter specifies the unique eBay-assigned identifier of the ad campaign associated with the negative keywords being retrieved.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from a specific campaign. The results might not include these campaign IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;b&gt;Note:&lt;/b&gt; Currently, only one campaign ID value is supported for each request.&lt;/span&gt;&lt;br&gt;&lt;br&gt; Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/campaign/methods/getCampaigns\&quot; target&#x3D;\&quot;_blank\&quot;&gt;getCampaigns&lt;/a&gt; method to retrieve campaign IDs. (optional)
     * @param  string|null $limit The number of results, from the current result set, to be returned in a single page. (optional)
     * @param  string|null $negativeKeywordStatus A comma-separated list of negative keyword statuses.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to filter the search results based on one or more negative keyword statuses.&lt;br&gt;&lt;br&gt; See &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/types/pls:NegativeKeywordStatusEnum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;NegativeKeywordStatusEnum&lt;/a&gt; for supported values. (optional)
     * @param  string|null $offset The number of results that will be skipped in the result set. This is used with the &lt;b&gt;limit&lt;/b&gt; field to control the pagination of the output.&lt;br /&gt;&lt;br /&gt;For example, if the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;0&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 1 through 10 from the list of items returned. If the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 11 through 20 from the list of items returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeywords'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNegativeKeywordsWithHttpInfo($adGroupIds = null, $campaignIds = null, $limit = null, $negativeKeywordStatus = null, $offset = null, string $contentType = self::contentTypes['getNegativeKeywords'][0])
    {
        $request = $this->getNegativeKeywordsRequest($adGroupIds, $campaignIds, $limit, $negativeKeywordStatus, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNegativeKeywordsAsync
     *
     * @param  string|null $adGroupIds A comma-separated list of ad group IDs.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from one or more specific ad groups. The results might not include these ad group IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/adgroup/methods/getAdGroups\&quot;&gt;getAdGroups&lt;/a&gt; method to retrieve the ad group IDs for a seller.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Required if&lt;/i&gt; the search results must be filtered to include negative keywords created at the ad group level. (optional)
     * @param  string|null $campaignIds This path parameter specifies the unique eBay-assigned identifier of the ad campaign associated with the negative keywords being retrieved.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from a specific campaign. The results might not include these campaign IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;b&gt;Note:&lt;/b&gt; Currently, only one campaign ID value is supported for each request.&lt;/span&gt;&lt;br&gt;&lt;br&gt; Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/campaign/methods/getCampaigns\&quot; target&#x3D;\&quot;_blank\&quot;&gt;getCampaigns&lt;/a&gt; method to retrieve campaign IDs. (optional)
     * @param  string|null $limit The number of results, from the current result set, to be returned in a single page. (optional)
     * @param  string|null $negativeKeywordStatus A comma-separated list of negative keyword statuses.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to filter the search results based on one or more negative keyword statuses.&lt;br&gt;&lt;br&gt; See &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/types/pls:NegativeKeywordStatusEnum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;NegativeKeywordStatusEnum&lt;/a&gt; for supported values. (optional)
     * @param  string|null $offset The number of results that will be skipped in the result set. This is used with the &lt;b&gt;limit&lt;/b&gt; field to control the pagination of the output.&lt;br /&gt;&lt;br /&gt;For example, if the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;0&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 1 through 10 from the list of items returned. If the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 11 through 20 from the list of items returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeywords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNegativeKeywordsAsync($adGroupIds = null, $campaignIds = null, $limit = null, $negativeKeywordStatus = null, $offset = null, string $contentType = self::contentTypes['getNegativeKeywords'][0])
    {
        return $this->getNegativeKeywordsAsyncWithHttpInfo($adGroupIds, $campaignIds, $limit, $negativeKeywordStatus, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNegativeKeywordsAsyncWithHttpInfo
     *
     * @param  string|null $adGroupIds A comma-separated list of ad group IDs.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from one or more specific ad groups. The results might not include these ad group IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/adgroup/methods/getAdGroups\&quot;&gt;getAdGroups&lt;/a&gt; method to retrieve the ad group IDs for a seller.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Required if&lt;/i&gt; the search results must be filtered to include negative keywords created at the ad group level. (optional)
     * @param  string|null $campaignIds This path parameter specifies the unique eBay-assigned identifier of the ad campaign associated with the negative keywords being retrieved.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from a specific campaign. The results might not include these campaign IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;b&gt;Note:&lt;/b&gt; Currently, only one campaign ID value is supported for each request.&lt;/span&gt;&lt;br&gt;&lt;br&gt; Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/campaign/methods/getCampaigns\&quot; target&#x3D;\&quot;_blank\&quot;&gt;getCampaigns&lt;/a&gt; method to retrieve campaign IDs. (optional)
     * @param  string|null $limit The number of results, from the current result set, to be returned in a single page. (optional)
     * @param  string|null $negativeKeywordStatus A comma-separated list of negative keyword statuses.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to filter the search results based on one or more negative keyword statuses.&lt;br&gt;&lt;br&gt; See &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/types/pls:NegativeKeywordStatusEnum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;NegativeKeywordStatusEnum&lt;/a&gt; for supported values. (optional)
     * @param  string|null $offset The number of results that will be skipped in the result set. This is used with the &lt;b&gt;limit&lt;/b&gt; field to control the pagination of the output.&lt;br /&gt;&lt;br /&gt;For example, if the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;0&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 1 through 10 from the list of items returned. If the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 11 through 20 from the list of items returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeywords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNegativeKeywordsAsyncWithHttpInfo($adGroupIds = null, $campaignIds = null, $limit = null, $negativeKeywordStatus = null, $offset = null, string $contentType = self::contentTypes['getNegativeKeywords'][0])
    {
        $returnType = '\macropage\SDKs\ebay\rest\marketing\Model\NegativeKeywordPagedCollectionResponse';
        $request = $this->getNegativeKeywordsRequest($adGroupIds, $campaignIds, $limit, $negativeKeywordStatus, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNegativeKeywords'
     *
     * @param  string|null $adGroupIds A comma-separated list of ad group IDs.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from one or more specific ad groups. The results might not include these ad group IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/adgroup/methods/getAdGroups\&quot;&gt;getAdGroups&lt;/a&gt; method to retrieve the ad group IDs for a seller.&lt;br /&gt;&lt;br /&gt;&lt;i&gt;Required if&lt;/i&gt; the search results must be filtered to include negative keywords created at the ad group level. (optional)
     * @param  string|null $campaignIds This path parameter specifies the unique eBay-assigned identifier of the ad campaign associated with the negative keywords being retrieved.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to retrieve the negative keywords from a specific campaign. The results might not include these campaign IDs if other search conditions exclude them.&lt;br /&gt;&lt;br /&gt;&lt;span class&#x3D;\&quot;tablenote\&quot;&gt;&lt;b&gt;Note:&lt;/b&gt; Currently, only one campaign ID value is supported for each request.&lt;/span&gt;&lt;br&gt;&lt;br&gt; Use the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/campaign/methods/getCampaigns\&quot; target&#x3D;\&quot;_blank\&quot;&gt;getCampaigns&lt;/a&gt; method to retrieve campaign IDs. (optional)
     * @param  string|null $limit The number of results, from the current result set, to be returned in a single page. (optional)
     * @param  string|null $negativeKeywordStatus A comma-separated list of negative keyword statuses.&lt;br /&gt;&lt;br /&gt;This query parameter is used if the seller wants to filter the search results based on one or more negative keyword statuses.&lt;br&gt;&lt;br&gt; See &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/types/pls:NegativeKeywordStatusEnum\&quot; target&#x3D;\&quot;_blank\&quot;&gt;NegativeKeywordStatusEnum&lt;/a&gt; for supported values. (optional)
     * @param  string|null $offset The number of results that will be skipped in the result set. This is used with the &lt;b&gt;limit&lt;/b&gt; field to control the pagination of the output.&lt;br /&gt;&lt;br /&gt;For example, if the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;0&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 1 through 10 from the list of items returned. If the &lt;b&gt;offset&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt; and the &lt;b&gt;limit&lt;/b&gt; is set to &lt;code&gt;10&lt;/code&gt;, the method will retrieve items 11 through 20 from the list of items returned. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getNegativeKeywords'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getNegativeKeywordsRequest($adGroupIds = null, $campaignIds = null, $limit = null, $negativeKeywordStatus = null, $offset = null, string $contentType = self::contentTypes['getNegativeKeywords'][0])
    {







        $resourcePath = '/negative_keyword';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $adGroupIds,
            'ad_group_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $campaignIds,
            'campaign_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $negativeKeywordStatus,
            'negative_keyword_status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNegativeKeyword
     *
     * @param  string $negativeKeywordId The unique identifier for the negative keyword.&lt;br /&gt;&lt;br /&gt;This value is returned in the &lt;b&gt;Location&lt;/b&gt; response header from the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/createNegativeKeyword\&quot;&gt;createNegativeKeyword&lt;/a&gt; method. (required)
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\UpdateNegativeKeywordRequest $updateNegativeKeywordRequest A type that defines the fields for the request to update a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateNegativeKeyword($negativeKeywordId, $updateNegativeKeywordRequest, string $contentType = self::contentTypes['updateNegativeKeyword'][0])
    {
        $this->updateNegativeKeywordWithHttpInfo($negativeKeywordId, $updateNegativeKeywordRequest, $contentType);
    }

    /**
     * Operation updateNegativeKeywordWithHttpInfo
     *
     * @param  string $negativeKeywordId The unique identifier for the negative keyword.&lt;br /&gt;&lt;br /&gt;This value is returned in the &lt;b&gt;Location&lt;/b&gt; response header from the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/createNegativeKeyword\&quot;&gt;createNegativeKeyword&lt;/a&gt; method. (required)
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\UpdateNegativeKeywordRequest $updateNegativeKeywordRequest A type that defines the fields for the request to update a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \macropage\SDKs\ebay\rest\marketing\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNegativeKeywordWithHttpInfo($negativeKeywordId, $updateNegativeKeywordRequest, string $contentType = self::contentTypes['updateNegativeKeyword'][0])
    {
        $request = $this->updateNegativeKeywordRequest($negativeKeywordId, $updateNegativeKeywordRequest, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation updateNegativeKeywordAsync
     *
     * @param  string $negativeKeywordId The unique identifier for the negative keyword.&lt;br /&gt;&lt;br /&gt;This value is returned in the &lt;b&gt;Location&lt;/b&gt; response header from the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/createNegativeKeyword\&quot;&gt;createNegativeKeyword&lt;/a&gt; method. (required)
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\UpdateNegativeKeywordRequest $updateNegativeKeywordRequest A type that defines the fields for the request to update a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNegativeKeywordAsync($negativeKeywordId, $updateNegativeKeywordRequest, string $contentType = self::contentTypes['updateNegativeKeyword'][0])
    {
        return $this->updateNegativeKeywordAsyncWithHttpInfo($negativeKeywordId, $updateNegativeKeywordRequest, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNegativeKeywordAsyncWithHttpInfo
     *
     * @param  string $negativeKeywordId The unique identifier for the negative keyword.&lt;br /&gt;&lt;br /&gt;This value is returned in the &lt;b&gt;Location&lt;/b&gt; response header from the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/createNegativeKeyword\&quot;&gt;createNegativeKeyword&lt;/a&gt; method. (required)
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\UpdateNegativeKeywordRequest $updateNegativeKeywordRequest A type that defines the fields for the request to update a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNegativeKeywordAsyncWithHttpInfo($negativeKeywordId, $updateNegativeKeywordRequest, string $contentType = self::contentTypes['updateNegativeKeyword'][0])
    {
        $returnType = '';
        $request = $this->updateNegativeKeywordRequest($negativeKeywordId, $updateNegativeKeywordRequest, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNegativeKeyword'
     *
     * @param  string $negativeKeywordId The unique identifier for the negative keyword.&lt;br /&gt;&lt;br /&gt;This value is returned in the &lt;b&gt;Location&lt;/b&gt; response header from the &lt;a href&#x3D;\&quot;/api-docs/sell/marketing/resources/negative_keyword/methods/createNegativeKeyword\&quot;&gt;createNegativeKeyword&lt;/a&gt; method. (required)
     * @param  \macropage\SDKs\ebay\rest\marketing\Model\UpdateNegativeKeywordRequest $updateNegativeKeywordRequest A type that defines the fields for the request to update a negative keyword. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateNegativeKeyword'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateNegativeKeywordRequest($negativeKeywordId, $updateNegativeKeywordRequest, string $contentType = self::contentTypes['updateNegativeKeyword'][0])
    {

        // verify the required parameter 'negativeKeywordId' is set
        if ($negativeKeywordId === null || (is_array($negativeKeywordId) && count($negativeKeywordId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $negativeKeywordId when calling updateNegativeKeyword'
            );
        }

        // verify the required parameter 'updateNegativeKeywordRequest' is set
        if ($updateNegativeKeywordRequest === null || (is_array($updateNegativeKeywordRequest) && count($updateNegativeKeywordRequest) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $updateNegativeKeywordRequest when calling updateNegativeKeyword'
            );
        }


        $resourcePath = '/negative_keyword/{negative_keyword_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($negativeKeywordId !== null) {
            $resourcePath = str_replace(
                '{' . 'negative_keyword_id' . '}',
                ObjectSerializer::toPathValue($negativeKeywordId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($updateNegativeKeywordRequest)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($updateNegativeKeywordRequest));
            } else {
                $httpBody = $updateNegativeKeywordRequest;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
